<?php

/**
 * @file
 *   Send site profile information (NSPI) and system data to Acquia Network.
 */

// Version of SPI data format.
define('ACQUIA_SPI_DATA_VERSION', 2.1);

/**
 * Identifiers for the method of sending SPI data.
 */
define('ACQUIA_SPI_METHOD_CALLBACK', 'menu');
define('ACQUIA_SPI_METHOD_CRON', 'cron');
define('ACQUIA_SPI_METHOD_DRUSH', 'drush');
define('ACQUIA_SPI_METHOD_CREDS', 'creds');
define('ACQUIA_SPI_METHOD_INSIGHT', 'insight');

/**
 * Put SPI data in local storage.
 *
 * @param array $data Keyed array of data to store.
 * @param int $expire Expire time or null to use default of 1 day.
 */
function acquia_spi_data_store_set($data, $expire = NULL) {
  if (is_null($expire)) {
    $expire = REQUEST_TIME + (60*60*24);
  }
  foreach ($data as $key => $value) {
    cache_set('acquia.spi.' . $key, $value, 'cache', $expire);
  }
}

/**
 * Implementation of hook_xmlrpc().
 */
function acquia_spi_xmlrpc() {
  return array(
    array(
      'acquia.nspi.send.module.data',
      'acquia_spi_send_module_data',
      array('string', 'array'),
      t('Send file data for the provided path.')),
    );
}

function acquia_spi_valid_request($data, $message) {
  $key = acquia_agent_settings('acquia_key');
  if (!isset($data['authenticator']) || !isset($data['authenticator']['time']) || !isset($data['authenticator']['nonce'])) {
    return FALSE;
  }
  $string = $data['authenticator']['time'] . ':' . $data['authenticator']['nonce'] . ':' . $message;
  $hash = sha1((str_pad($key, 64, chr(0x00)) ^ (str_repeat(chr(0x5c), 64))) . pack("H*", sha1((str_pad($key, 64, chr(0x00)) ^ (str_repeat(chr(0x36), 64))) . $string)));
  if ($hash == $data['authenticator']['hash']) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Send a file's contents to the requestor
 */
function acquia_spi_send_module_data($data = array()) {
  // We only do this if we are on SSL
  $via_ssl = isset($_SERVER['HTTPS']) ? TRUE : FALSE;
  if (variable_get('acquia_spi_module_diff_data', 1) && $via_ssl
      && acquia_agent_has_credentials() && isset($data['body']['file'])
      && acquia_spi_valid_request($data, $data['body']['file'])) {
    // If our checks pass muster, then we'll provide this data.
    // If the file variable is set and if the user has allowed file diffing.
    $file = $data['body']['file'];
    $document_root = getcwd();
    $file_path = realpath($document_root . '/' . $file);
    // Be sure the file being requested is within the webroot and is not any
    // settings.php file.
    if (is_file($file_path) && strpos($file_path, $document_root) === 0 && strpos($file_path, 'settings.php') === FALSE) {
      $file_contents = file_get_contents($file_path);
      header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");
      header("Content-Type:text");
      header("Cache-Control: no-cache");
      header("Pragma: no-cache");
      return $file_contents;
    }
  }

  return FALSE;
}

/**
 * Added submit function for acquia_agent_settings form.
 */
function acquia_spi_agent_settings_submit($form, &$form_state) {
  // Send information as soon as the key/identifier pair is submitted.
  acquia_connector_send_full_spi(ACQUIA_SPI_METHOD_CREDS);
}

/**
 * Send data to Acquia Network.
 *
 * Note, call acquia_spi_send_full_spi() to support SPI response actions.
 *
 * @param array $spi SPI data. Required parameters:
 *   'site_key' A SHA1 hash of the Drupal private key.
 *   'spi_data_version'
 *   @see acquia_spi_get().
 *
 *   Note, acquia_agent will add authenticator.
 * @return mixed FALSE if no credentials or validation error else full
 *   NSPI response array.
 */
function acquia_spi_send_data($spi) {
  // Do nothing unless we have credentials.
  if (!acquia_agent_has_credentials()) {
    watchdog('acquia spi', 'Connect your site to a valid subscription on the Acquia Network to send SPI data', array(), WATCHDOG_ERROR);
    return FALSE;
  }
  // acquia_agent_network_address() sets remote server protocol.
  $nspi_server = variable_get('acquia_spi_server', 'https://nspi.acquia.com');
  // Specify version 3 of the RPC, which ommits request parameters in the HMAC.
  $spi['rpc_version'] = 3;
  $response = acquia_agent_call('acquia.nspi.update', $spi, NULL, NULL, $nspi_server);
  // Validate the server response.
  if (!acquia_agent_valid_response($response, acquia_agent_settings('acquia_key'))) {
    // Acquia Agent will have logged error.
    return FALSE;
  }
  // $response contains request authenticator as well as server authenticator
  // under 'result' element so return just the server response 'body' element.
  return $response['result']['body'];
}

/**
 * Implements hook_enable().
 *
 */
function acquia_spi_test_enable() {

  $modules = module_implements('acquia_spi_test');
  foreach ($modules as $module) {
    if (function_exists($module . '_acquia_spi_test')) {
      drupal_set_message(t("An invokation of hook_acquia_spi_test() has been detected in @module.", array('@module' => $module)));
      watchdog('acquia agent', "An invokation of hook_acquia_spi_test() has been detected in @module.", array('@module' => $module));
    }
  }
}

/**
 * Implements hook_modules_enabled().
 *
 */
function acquia_spi_test_modules_enabled($modules) {

  foreach ($modules as $module) {
    if (function_exists($module . '_acquia_spi_test')) {
      drupal_set_message(t("A new invokation of hook_acquia_spi_test() has been detected in @module.", array('@module' => $module)));
      watchdog('acquia spi test', "A new invokation of hook_acquia_spi_test() has been detected in @module.", array('@module' => $module));
    }
  }
}

/**
 * Determines if settings.php is read-only
 *
 * @param n/a
 *
 * @return boolean
 *
 */
function acquia_spi_get_settings_permissions() {
  $settings_permissions_read_only = TRUE;
  $writes = array('2', '3', '6', '7'); // http://en.wikipedia.org/wiki/File_system_permissions
  $settings_file = './' . conf_path(FALSE, TRUE) . '/settings.php';
  $permissions = drupal_substr(sprintf('%o', fileperms($settings_file)), -4);

  foreach ($writes as $bit) {
    if (strpos($permissions, $bit)) {
      $settings_permissions_read_only = FALSE;
      break;
    }
  }

  return $settings_permissions_read_only;
}

/**
 * Check to see if the unneeded release files with Drupal are removed
 *
 * @param n/a
 *
 * @return
 *   True if they are removed, false if they aren't
 */
function acquia_spi_check_files_present() {
  $store = acquia_spi_data_store_get(array('platform'));
  $server = (!empty($store) && isset($store['platform'])) ? $store['platform']['php_quantum']['SERVER'] : $_SERVER;
  $files_exist = FALSE;
  $url = url(NULL, array('absolute' => TRUE));
  $files_to_remove = array('CHANGELOG.txt', 'COPYRIGHT.txt', 'INSTALL.mysql.txt', 'INSTALL.pgsql.txt', 'INSTALL.txt', 'LICENSE.txt',
    'MAINTAINERS.txt', 'README.txt', 'UPGRADE.txt', 'PRESSFLOW.txt', 'install.php');

  foreach ($files_to_remove as $file) {
    $path = $server['DOCUMENT_ROOT'] . base_path() . $file;
    if (file_exists($path))
      $files_exist = TRUE;
  }

  return $files_exist ? 1 : 0;
}

/**
 * Get last 15 users created. Useful for determining if your site is compromised.
 *
 * @return array
 *   The details of last 15 users created.
 */
function acquai_spi_get_last_users() {
  $last_five_users = array();
  $result = db_select('users', 'u')
    ->fields('u', array('uid', 'name', 'mail', 'created'))
    ->condition('u.created', REQUEST_TIME - 3600, '>')
    ->orderBy('created', 'DESC')
    ->range(0, 15)
    ->execute();

  $count = 0;
  foreach ($result as $record) {
    $last_five_users[$count]['uid'] = $record->uid;
    $last_five_users[$count]['name'] = $record->name;
    $last_five_users[$count]['email'] = $record->mail;
    $last_five_users[$count]['created'] = $record->created;
    $count++;
  }
//TODO is this what we really want?
  return $last_five_users;
}

/**
 * Get last 15 nodes created--this can be useful to determine if you have some
 * sort of spamme on your site
 *
 * @param n/a
 *
 * @return array of the details of last 15 nodes created
 */
function acquai_spi_get_last_nodes() {
  $last_five_nodes = array();
  $result = db_select('node', 'n')
    ->fields('n', array('title', 'type', 'nid', 'created'))
    ->condition('n.created', REQUEST_TIME - 3600, '>')
    ->orderBy('n.created', 'DESC')
    ->range(0, 15)
    ->execute();

  $count = 0;
  foreach ($result as $record) {
    $last_five_nodes[$count]['url'] = drupal_get_path_alias('node/' . $record->nid);
    $last_five_nodes[$count]['title'] = $record->title;
    $last_five_nodes[$count]['type'] = $record->type;
    $last_five_nodes[$count]['created'] = $record->created;
    $count++;
  }

  return $last_five_nodes;

}

/**
 * Get the number of rows in watchdog
 *
 * @param n/a
 *
 * @return int
 *
 */
function acquai_spi_get_watchdog_size() {
  if (module_exists('dblog')) {
    return db_select('watchdog', 'w')->fields('w', array('wid'))->countQuery()->execute()->fetchField();
  }
}

/**
 * Get the latest (last hour) critical and emergency warnings from watchdog
 * These errors are 'severity' 0 and 2.
 *
 * @param n/a
 *
 * @return array
 *
 */
function acquia_spi_get_watchdog_data() {
  $wd = array();
  if (module_exists('dblog')) {
    $result = db_select('watchdog', 'w')
      ->fields('w', array('wid', 'severity', 'type', 'message', 'timestamp'))
      ->condition('w.severity', array(WATCHDOG_EMERGENCY, WATCHDOG_CRITICAL), 'IN')
      ->condition('w.timestamp', REQUEST_TIME - 3600, '>')
      ->execute();

    while ($record = $result->fetchAssoc()) {
      $wd[$record['severity']] = $record;
    }
  }
  return $wd;
}

/**
 * Grabs the last 404 errors in logs, excluding the checks we run for drupal files like README
 *
 * @param n/a
 *
 * @return
 *   An array of the pages not found and some associated data
 */
function acquai_spi_get_404s() {
  $data = array();
  $row = 0;

  if (module_exists('dblog')) {
    $result = db_select('watchdog', 'w')
      ->fields('w', array('message', 'hostname', 'referer', 'timestamp'))
      ->condition('w.type', 'page not found', '=')
      ->condition('w.timestamp', REQUEST_TIME - 3600, '>')
      ->condition('w.message', array("UPGRADE.txt", "MAINTAINERS.txt", "README.txt", "INSTALL.pgsql.txt", "INSTALL.txt", "LICENSE.txt", "INSTALL.mysql.txt", "COPYRIGHT.txt", "CHANGELOG.txt"), 'NOT IN')
      ->orderBy('w.timestamp', 'DESC')
      ->range(0, 10)
      ->execute();

    foreach ($result as $record) {
      $data[$row]['message'] = $record->message;
      $data[$row]['hostname'] = $record->hostname;
      $data[$row]['referer'] = $record->referer;
      $data[$row]['timestamp'] = $record->timestamp;
      $row++;
    }
  }

  return $data;
}

/**
 * Get all system variables
 *
 * @return JSON string
 */
function acquia_spi_get_variables_data() {
  global $conf;
  $data = array();
  $variables = array('acquia_spi_send_node_user', 'acquia_spi_admin_priv', 'acquia_spi_module_diff_data', 'acquia_spi_send_watchdog', 'acquia_spi_use_cron', 'cache_backends', 'cache_default_class', 'cache_inc', 'cron_safe_threshold', 'googleanalytics_cache', 'error_level', 'preprocess_js', 'page_cache_maximum_age', 'block_cache', 'preprocess_css', 'page_compression', 'cache', 'cache_lifetime', 'cron_last', 'clean_url', 'redirect_global_clean', 'theme_zen_settings', 'site_offline', 'site_name', 'user_register', 'user_signatures', 'user_admin_role', 'user_email_verification', 'user_cancel_method', 'filter_fallback_format', 'dblog_row_limit', 'date_default_timezone', 'file_default_scheme', 'install_profile', 'maintenance_mode', 'update_last_check', 'site_default_country', 'acquia_spi_saved_variables', 'acquia_spi_set_variables_automatic', 'acquia_spi_ignored_set_variables', 'acquia_spi_set_variables_override');
  $spi_def_vars = variable_get('acquia_spi_def_vars', array());
  $waived_spi_def_vars = variable_get('acquia_spi_def_waived_vars', array());
  // Merge hard coded $variables with vars from SPI definition.
  foreach($spi_def_vars as $var_name => $var) {
    if (!in_array($var_name, $waived_spi_def_vars) && !in_array($var_name, $variables)) {
      $variables[] = $var_name;
    }
  }
  // Add comment settings for node types.
  $types = node_type_get_types();
  if (!empty($types)) {
    foreach ($types as $name => $type) {
      $variables[] = 'comment_' . $name;
    }
  }
  foreach ($variables as $name) {
    if (isset($conf[$name])) {
      $data[$name] = $conf[$name];
    }
  }
  // Exception handling.
  if (module_exists('globalredirect') && function_exists('_globalredirect_get_settings')) {
    // Explicitly get Global Redirect settings since it deletes its variable
    // if the settings match the defaults.
    $data['globalredirect_settings'] = _globalredirect_get_settings();
  }
  // Drush overrides cron_safe_threshold so extract DB value if sending via drush.
  if (drupal_is_cli()) {
    $cron_safe_threshold = acquia_spi_get_db_variable('cron_safe_threshold');
    $data['cron_safe_threshold'] = !is_null($cron_safe_threshold) ? $cron_safe_threshold : DRUPAL_CRON_DEFAULT_THRESHOLD;
  }
  // Unset waived vars so they won't be sent to NSPI.
  foreach($data as $var_name => $var) {
    if (in_array($var_name, $waived_spi_def_vars)) {
      unset($data[$var_name]);
    }
  }
  // Collapse to JSON string to simplify transport.
  return drupal_json_encode($data);
}

/**
 * Get a variable from the DB explicitely skipping global $conf array.
 */
function acquia_spi_get_db_variable($name) {
  $result = db_query("SELECT value FROM {variable} WHERE name = :name", array(':name' => $name));
  if ($result->rowCount() == 1) {
    return unserialize($result->fetchField());
  }
  return NULL;
}

/**
 * Get the information on failed logins in the last cron interval
 *
 * @param n/a
 *
 * @return array
 *
 */
function acquia_spi_get_failed_logins() {
  $last_logins = array();
  $cron_interval = variable_get('acquia_spi_cron_interval', 8*60*60);

  if (module_exists('dblog')) {
    $result = db_select('watchdog', 'w')
      ->fields('w', array('message', 'variables'))
      ->condition('w.message', 'login attempty failed%', 'LIKE')
      ->condition('w.timestamp', REQUEST_TIME - $cron_interval, '>')
      ->condition('w.message', array("UPGRADE.txt", "MAINTAINERS.txt", "README.txt", "INSTALL.pgsql.txt", "INSTALL.txt", "LICENSE.txt", "INSTALL.mysql.txt", "COPYRIGHT.txt", "CHANGELOG.txt"), 'NOT IN')
      ->orderBy('w.timestamp', 'DESC')
      ->range(0, 10)
      ->execute();

    foreach ($result as $record) {
      $variables = unserialize($record->variables);
      $last_logins['failed'][$record->timestamp] = check_plain($variables['%user']);
    }
  }
  return $last_logins;
}

/**
 * Determine if the super user has a weak name
 *
 * @return boolean
 */
function acquia_spi_get_super_name() {
  $result = db_query("SELECT name FROM {users} WHERE uid = 1 AND (name LIKE '%admin%' OR name LIKE '%root%')")->fetch();
  if ($result) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * The number of users who have admin-level user roles.
 *
 * @param n/a
 *
 * @return int
 *
 */
function acquia_spi_get_admin_count() {
  $count = NULL;
  $sql = "SELECT COUNT(DISTINCT u.uid) as count
              FROM {users} u, {users_roles} ur, {role_permission} p
              WHERE u.uid = ur.uid
                AND ur.rid = p.rid
                AND u.status = 1
                AND (p.permission = 'administer permissions' OR p.permission = 'administer users')";
  $result = db_query($sql)->fetchObject();

  return (isset($result->count) && is_numeric($result->count)) ? $result->count : NULL;
}

/**
 * This function is a trimmed version of Drupal's system_status function
 *
 * @return array
 */
function acquia_spi_get_system_status() {
  $data = array();

  $profile = drupal_get_profile();
  if ($profile != 'standard') {
    $info = system_get_info('module', $profile);
    $data['install_profile'] = array(
      'title' => 'Install profile',
      'value' => t('%profile_name (%profile-%version)', array(
        '%profile_name' => $info['name'],
        '%profile' => $profile,
        '%version' => $info['version'],
      )),
    );
  }
  $data['php'] = array(
    'title' => 'PHP',
    'value' => phpversion(),
  );
  $conf_dir = TRUE;
  $settings = TRUE;
  $dir = conf_path();
  if (is_writable($dir) || is_writable($dir . '/settings.php')) {
    $value = 'Not protected';
    if (is_writable($dir)) {
      $conf_dir = FALSE;
    }
    elseif (is_writable($dir . '/settings.php')) {
      $settings = FALSE;
    }
  }
  else {
    $value = 'Protected';
  }
  $data['settings.php'] = array(
    'title' => 'Configuration file',
    'value' => $value,
    'conf_dir' => $conf_dir,
    'settings' => $settings,
  );
  $cron_last = variable_get('cron_last', NULL);
  if (!is_numeric($cron_last)) {
    $cron_last = variable_get('install_time', 0);
  }
  $data['cron'] = array(
    'title' => 'Cron maintenance tasks',
    'value' => t('Last run !time ago', array('!time' => format_interval(REQUEST_TIME - $cron_last))),
    'cron_last' => $cron_last,
  );
  if (!empty($GLOBALS['update_free_access'])) {
    $data['update access'] = array(
      'value' => 'Not protected',
      'protected' => FALSE,
    );
  }
  else {
    $data['update access'] = array(
      'value' => 'Protected',
      'protected' => TRUE,
    );
  }
  $data['update access']['title'] = 'Access to update.php';
  if (!module_exists('update')) {
    $data['update status'] = array(
      'value' => 'Not enabled',
    );
  }
  else {
    $data['update status'] = array(
      'value' => 'Enabled',
    );
  }
  $data['update status']['title'] = 'Update notifications';
  return $data;
}

/**
 * Gather information about modules on the site.
 *
 * @return
 *   An associative array keyed by filename of associative arrays with
 *   information on the modules.
 */
function acquia_spi_get_modules() {
  // Only do a full rebuild of the module cache every 1 at the most
  $last_build = variable_get('acquia_spi_module_rebuild', 0);
  if ($last_build < REQUEST_TIME - 86400) {
    $modules = system_rebuild_module_data();
    variable_set('acquia_spi_module_rebuild', REQUEST_TIME);
  }
  else {
    $result = db_query("SELECT filename, name, type, status, schema_version, info FROM {system} WHERE type = 'module'");
    foreach ($result as $file) {
      $file->info = unserialize($file->info);
      $modules[$file->filename] = $file;
    }
  }

  $result = array();
  $keys_to_send = array('name', 'version', 'package', 'core', 'project');
  foreach ($modules as $filename => $file) {
    $info = array();
    $info['status'] = $file->status;
    foreach ($keys_to_send as $key) {
      $info[$key] = isset($file->info[$key]) ? $file->info[$key] : '';
    }
    $info['filename'] = $file->filename;

    // Determine which files belong to this module and hash them
    $module_path = explode('/', $file->filename);
    array_pop($module_path);

    // We really only care about this module if it is in 'sites' folder.
    // Otherwise it is covered by the hash of the distro's modules
    if ($module_path[0]=='sites') {
      $contrib_path = implode('/', $module_path);

      // Get a hash for this module's files. If we nest into another module, we'll return
      // and that other module will be covered by it's entry in the system table.
      //
      // !! At present we aren't going to do a per module hash, but rather a per-project hash. The reason being that it is
      // too hard to tell an individual module appart from a project
      //$info['module_data'] = _acquia_nspi_generate_hashes($contrib_path,array(),array(),TRUE,$contrib_path);
      list($info['module_data']['hashes'], $info['module_data']['fileinfo']) = _acquia_spi_generate_hashes($contrib_path);
    }
    else {
      $info['module_data']['hashes'] = array();
      $info['module_data']['fileinfo'] = array();
    }

    $result[] = $info;
  }
  return $result;
}

/**
 * Gather information about nodes, users and comments.
 *
 * @return
 *   An associative array.
 */
function acquia_spi_get_quantum() {
  $quantum = array();
  // Get only published nodes.
  $quantum['nodes'] = db_select('node', 'n')->fields('n', array('nid'))->condition('n.status', NODE_PUBLISHED)->countQuery()->execute()->fetchField();
  // Get only active users.
  $quantum['users'] = db_select('users', 'u')->fields('u', array('uid'))->condition('u.status', 1)->countQuery()->execute()->fetchField();
  if (module_exists('comment')) {
    // Get only active comments.
    $quantum['comments'] = db_select('comment', 'c')->fields('c', array('cid'))->condition('c.status', COMMENT_PUBLISHED)->countQuery()->execute()->fetchField();
  }

  return $quantum;
}

/**
 * Check the presence of UID 0 in the users table.
 *
 * @return bool Whether UID 0 is present.
 *
 */
function acquia_spi_uid_0_present() {
  $count = db_query("SELECT uid FROM {users} WHERE uid = 0")->rowCount();
  return $count == 1 ? TRUE : FALSE;
}

/**
 * Gather hashes of all important files, ignoring line ending and CVS Ids
 *
 * @param $excuded_dirs
 *   Optional array of directory paths to be excluded.
 *
 * @return
 *   An associative array keyed by filename of hashes.
 */
function acquia_spi_file_hashes($exclude_dirs = array()) {
  // The list of directories for the third parameter are the only ones that
  // will be recursed into.  Thus, we avoid sending hashes for any others.
  list($hashes, $fileinfo) = _acquia_spi_generate_hashes('.', $exclude_dirs, array('modules', 'profiles', 'themes', 'includes', 'misc', 'scripts'));
  ksort($hashes);
  // Add .htaccess file.
  $htaccess = DRUPAL_ROOT . DIRECTORY_SEPARATOR . '.htaccess';
  if (is_file($htaccess)) {
    $owner = fileowner($htaccess);
    if (function_exists('posix_getpwuid')) {
      $userinfo = posix_getpwuid($owner);
      $owner = $userinfo['name'];
    }
    $fileinfo['.htaccess'] = 'mt:' . filemtime($htaccess) . '$p:' . substr(sprintf('%o', fileperms($htaccess)), -4) . '$o:' . $owner . '$s:' . filesize($htaccess);
  }
  return array($hashes, $fileinfo);
}

/**
 * Recursive helper function for acquia_spi_file_hashes().
 */
function _acquia_spi_generate_hashes($dir, $exclude_dirs = array(), $limit_dirs = array(), $module_break = FALSE, $orig_dir=NULL) {
  $hashes = array();
  $fileinfo = array();

  // Ensure that we have not nested into another module's dir
  if ($dir != $orig_dir && $module_break) {
    if (is_dir($dir) && $handle = opendir($dir)) {
      while ($file = readdir($handle)) {
        if (stristr($file, '.module')) {
          return;
        }
      }
    }
  }
  if (isset($handle)) {
    closedir($handle);
  }

  // Standard nesting function
  if (is_dir($dir) && $handle = opendir($dir)) {
    while ($file = readdir($handle)) {
      if (!in_array($file, array('.', '..', 'CVS', '.svn'))) {
        $path = $dir == '.' ? $file : "{$dir}/{$file}";
        if (is_dir($path) && !in_array($path, $exclude_dirs) && (empty($limit_dirs) || in_array($path, $limit_dirs)) && ($file != 'translations')) {
          list($sub_hashes, $sub_fileinfo) =  _acquia_spi_generate_hashes($path, $exclude_dirs);
          $hashes = array_merge($sub_hashes, $hashes);
          $fileinfo = array_merge($sub_fileinfo, $fileinfo);
          $hashes[$path] = acquia_spi_hash_path($path);
        }
        elseif (acquia_spi_is_manifest_type($file)) {
          $hashes[$path] = acquia_spi_hash_path($path);
          $owner = fileowner($path);
          if (function_exists('posix_getpwuid')) {
            $userinfo = posix_getpwuid($owner);
            $owner = $userinfo['name'];
          }
          $fileinfo[$path] = 'mt:' . filemtime($path) . '$p:' . substr(sprintf('%o', fileperms($path)), -4) . '$o:' . $owner . '$s:' . filesize($path);
        }
      }
    }
    closedir($handle);
  }

  return array($hashes, $fileinfo);
}

/**
 * Determine if a path is a file type we care about for modificaitons.
 */
function acquia_spi_is_manifest_type($path) {
  $extensions = array(
    'php' => 1,
    'php4' => 1,
    'php5' => 1,
    'module' => 1,
    'inc' => 1,
    'install' => 1,
    'test' => 1,
    'theme' => 1,
    'engine' => 1,
    'profile' => 1,
    'css' => 1,
    'js' => 1,
    'info' => 1,
    'sh' => 1,
    // SSL certificates
    'pem' => 1,
    'pl' => 1,
    'pm' => 1,
  );
  $pathinfo = pathinfo($path);
  return isset($pathinfo['extension']) && isset($extensions[$pathinfo['extension']]);
}

/**
 * Calculate the sha1 hash for a path.
 *
 * @param $path
 *   The name of the file or a directory.
 * @return
 *   bas64 encoded sha1 hash. 'hash' is an empty string for directories.
 */
function acquia_spi_hash_path($path = '') {
  $hash = '';
  if (file_exists($path)) {
    if (!is_dir($path)) {
      $string = file_get_contents($path);
      // Remove trailing whitespace
      $string = rtrim($string);
      // Replace all line endings and CVS/svn Id tags
      $string = preg_replace('/\$Id[^;<>{}\(\)\$]*\$/', 'x$' . 'Id$', $string);
      $string = preg_replace('/\r\n|\n|\r/', ' ', $string);
      $hash =  base64_encode(pack("H*", sha1($string)));
    }
  }
  return $hash;
}

/**
 * Set variables from NSPI response.
 *
 * @param  array $set_variables Variables to be set.
 * @return NULL
 */
function acquia_spi_set_variables($set_variables) {
  if (empty($set_variables)) {
    return;
  }
  $saved = array();
  $ignored = variable_get('acquia_spi_ignored_set_variables', array());

  if (!variable_get('acquia_spi_set_variables_override', 0)) {
    $ignored[] = 'acquia_spi_set_variables_automatic';
  }
  // Some variables can never be set.
  $ignored = array_merge($ignored, array('drupal_private_key', 'site_mail', 'site_name', 'maintenance_mode', 'user_register'));
  // Variables that can be automatically set.
  $whitelist = acquia_spi_approved_set_variables();
  foreach($set_variables as $key => $value) {
    // Approved variables get set immediately unless ignored.
    if (in_array($key, $whitelist) && !in_array($key, $ignored)) {
      $saved[] = $key;
      variable_set($key, $value);
    }
  }
  if (!empty($saved)) {
    variable_set('acquia_spi_saved_variables', array('variables' => $saved, 'time' => time()));
    watchdog('acquia spi', 'Saved variables from the Acquia Network: @variables', array('@variables' => implode(', ', $saved)), WATCHDOG_INFO);
  }
  else {
    watchdog('acquia spi', 'Did not save any variables from the Acquia Network.', array(), WATCHDOG_INFO);
  }
}

/**
 * Variables that can be automatically set by the NSPI set variables command.
 *
 * @return array Array of variable names.
 */
function acquia_spi_approved_set_variables() {
  // acquia_spi_set_variables_automatic is in here so that if
  // acquia_spi_set_variables_override is TRUE then it can be automatically set.
  return variable_get('acquia_spi_set_variables_automatic', array('acquia_spi_set_variables_automatic', 'error_level', 'preprocess_js', 'page_cache_maximum_age', 'block_cache', 'preprocess_css', 'page_compression', 'cache', 'cache_lifetime', 'image_allow_insecure_derivatives', 'googleanalytics_cache', 'acquia_spi_send_node_user', 'acquia_spi_admin_priv', 'acquia_spi_module_diff_data', 'acquia_spi_send_watchdog', 'acquia_spi_use_cron'));
}
